{
  "version": 3,
  "sources": ["../../@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js", "../../@monogrid/gainmap-js/dist/decode.js"],
  "sourcesContent": ["/**\n * @monogrid/gainmap-js v3.0.5\n * With ‚ù§Ô∏è, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { RGBAFormat, LinearFilter, ClampToEdgeWrapping, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, MeshBasicMaterial } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @params options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n", "/**\n * @monogrid/gainmap-js v3.0.5\n * With ‚ù§Ô∏è, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getAttribute = (description, name, defaultValue) => {\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName('rdf:li');\n            if (values.length === 3) {\n                returnValue = Array.from(values).map(v => v.innerHTML);\n            }\n            else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        }\n        else {\n            if (defaultValue)\n                return defaultValue;\n            else\n                throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    }\n    else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = (input) => {\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    const parser = new DOMParser();\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin)\n                hdrCapacityMin = '0';\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax)\n                throw new Error('Incomplete gainmap metadata');\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n"],
  "mappings": "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",
  "names": []
}
